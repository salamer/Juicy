// Code generated by protoc-gen-go. DO NOT EDIT.
// source: commandpb/command.proto

/*
Package Juicy is a generated protocol buffer package.

It is generated from these files:
	commandpb/command.proto

It has these top-level messages:
	CommandReq
	CommandResp
*/
package Juicy

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CommandReq_Command int32

const (
	CommandReq_Set     CommandReq_Command = 0
	CommandReq_Get     CommandReq_Command = 1
	CommandReq_Have    CommandReq_Command = 2
	CommandReq_Empty   CommandReq_Command = 3
	CommandReq_Clear   CommandReq_Command = 4
	CommandReq_Delete  CommandReq_Command = 5
	CommandReq_Persist CommandReq_Command = 6
)

var CommandReq_Command_name = map[int32]string{
	0: "Set",
	1: "Get",
	2: "Have",
	3: "Empty",
	4: "Clear",
	5: "Delete",
	6: "Persist",
}
var CommandReq_Command_value = map[string]int32{
	"Set":     0,
	"Get":     1,
	"Have":    2,
	"Empty":   3,
	"Clear":   4,
	"Delete":  5,
	"Persist": 6,
}

func (x CommandReq_Command) String() string {
	return proto.EnumName(CommandReq_Command_name, int32(x))
}
func (CommandReq_Command) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type CommandReq struct {
	Command CommandReq_Command `protobuf:"varint,1,opt,name=command,enum=Juicy.CommandReq_Command" json:"command,omitempty"`
	Key     string             `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value   string             `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *CommandReq) Reset()                    { *m = CommandReq{} }
func (m *CommandReq) String() string            { return proto.CompactTextString(m) }
func (*CommandReq) ProtoMessage()               {}
func (*CommandReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CommandReq) GetCommand() CommandReq_Command {
	if m != nil {
		return m.Command
	}
	return CommandReq_Set
}

func (m *CommandReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CommandReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CommandResp struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Empty   bool   `protobuf:"varint,3,opt,name=empty" json:"empty,omitempty"`
	Have    bool   `protobuf:"varint,4,opt,name=have" json:"have,omitempty"`
	Value   string `protobuf:"bytes,5,opt,name=value" json:"value,omitempty"`
}

func (m *CommandResp) Reset()                    { *m = CommandResp{} }
func (m *CommandResp) String() string            { return proto.CompactTextString(m) }
func (*CommandResp) ProtoMessage()               {}
func (*CommandResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CommandResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CommandResp) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *CommandResp) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

func (m *CommandResp) GetHave() bool {
	if m != nil {
		return m.Have
	}
	return false
}

func (m *CommandResp) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*CommandReq)(nil), "Juicy.CommandReq")
	proto.RegisterType((*CommandResp)(nil), "Juicy.CommandResp")
	proto.RegisterEnum("Juicy.CommandReq_Command", CommandReq_Command_name, CommandReq_Command_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DBCommand service

type DBCommandClient interface {
	CommandRPC(ctx context.Context, in *CommandReq, opts ...grpc.CallOption) (*CommandResp, error)
}

type dBCommandClient struct {
	cc *grpc.ClientConn
}

func NewDBCommandClient(cc *grpc.ClientConn) DBCommandClient {
	return &dBCommandClient{cc}
}

func (c *dBCommandClient) CommandRPC(ctx context.Context, in *CommandReq, opts ...grpc.CallOption) (*CommandResp, error) {
	out := new(CommandResp)
	err := grpc.Invoke(ctx, "/Juicy.DBCommand/CommandRPC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DBCommand service

type DBCommandServer interface {
	CommandRPC(context.Context, *CommandReq) (*CommandResp, error)
}

func RegisterDBCommandServer(s *grpc.Server, srv DBCommandServer) {
	s.RegisterService(&_DBCommand_serviceDesc, srv)
}

func _DBCommand_CommandRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DBCommandServer).CommandRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Juicy.DBCommand/CommandRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DBCommandServer).CommandRPC(ctx, req.(*CommandReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _DBCommand_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Juicy.DBCommand",
	HandlerType: (*DBCommandServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CommandRPC",
			Handler:    _DBCommand_CommandRPC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "commandpb/command.proto",
}

func init() { proto.RegisterFile("commandpb/command.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 275 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xcd, 0x4e, 0x83, 0x40,
	0x14, 0x85, 0x4b, 0xf9, 0xbf, 0x4d, 0xcc, 0x78, 0x63, 0x22, 0xba, 0x6a, 0x58, 0x75, 0x85, 0x49,
	0x1b, 0x5f, 0xa0, 0xd4, 0x68, 0x5c, 0x35, 0xe8, 0x0b, 0x50, 0xbc, 0x89, 0x8d, 0x20, 0xe3, 0xcc,
	0x40, 0xc2, 0xc2, 0x67, 0xf3, 0xd5, 0xcc, 0x0c, 0x50, 0x8c, 0xdd, 0x7d, 0xe7, 0x70, 0x08, 0xe7,
	0x5c, 0xe0, 0xba, 0xa8, 0xab, 0x2a, 0xff, 0x7c, 0xe3, 0x87, 0xbb, 0x81, 0x12, 0x2e, 0x6a, 0x55,
	0xa3, 0xfb, 0xdc, 0x1c, 0x8b, 0x2e, 0xfe, 0xb1, 0x00, 0xd2, 0xfe, 0x41, 0x46, 0x5f, 0xb8, 0x01,
	0x7f, 0x88, 0x45, 0xd6, 0xd2, 0x5a, 0x5d, 0xac, 0x6f, 0x12, 0x93, 0x4b, 0xa6, 0xcc, 0x09, 0xc7,
	0x24, 0x32, 0xb0, 0x3f, 0xa8, 0x8b, 0xe6, 0x4b, 0x6b, 0x15, 0x66, 0x1a, 0xf1, 0x0a, 0xdc, 0x36,
	0x2f, 0x1b, 0x8a, 0x6c, 0xe3, 0xf5, 0x22, 0x7e, 0x05, 0x7f, 0x78, 0x17, 0x7d, 0xb0, 0x5f, 0x48,
	0xb1, 0x99, 0x86, 0x47, 0x52, 0xcc, 0xc2, 0x00, 0x9c, 0xa7, 0xbc, 0x25, 0x36, 0xc7, 0x10, 0xdc,
	0x87, 0x8a, 0xab, 0x8e, 0xd9, 0x1a, 0xd3, 0x92, 0x72, 0xc1, 0x1c, 0x04, 0xf0, 0x76, 0x54, 0x92,
	0x22, 0xe6, 0xe2, 0x02, 0xfc, 0x3d, 0x09, 0x79, 0x94, 0x8a, 0x79, 0xf1, 0x37, 0x2c, 0x4e, 0xe5,
	0x24, 0xc7, 0x08, 0x7c, 0xd9, 0x14, 0x05, 0x49, 0x69, 0x16, 0x04, 0xd9, 0x28, 0x75, 0x29, 0x12,
	0xa2, 0x16, 0x43, 0xd1, 0x5e, 0x18, 0x57, 0x7f, 0xcd, 0x54, 0x0d, 0xb2, 0x5e, 0x20, 0x82, 0xf3,
	0x9e, 0xb7, 0x14, 0x39, 0xc6, 0x34, 0x3c, 0x8d, 0x72, 0xff, 0x8c, 0x5a, 0x6f, 0x21, 0xdc, 0x6d,
	0xc7, 0x59, 0xf7, 0xd3, 0x31, 0xf7, 0x29, 0x5e, 0x9e, 0xdd, 0xee, 0x16, 0xff, 0x5b, 0x92, 0xc7,
	0xb3, 0x83, 0x67, 0x7e, 0xc9, 0xe6, 0x37, 0x00, 0x00, 0xff, 0xff, 0xbe, 0xdb, 0x05, 0x5c, 0xad,
	0x01, 0x00, 0x00,
}
